<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Retro rage run</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body, html {
    height: 100%;
    background: linear-gradient(to bottom, #87ceeb, #3b5998);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
  }
  #gameCanvas {
    display: block;
    margin: auto;
    background: #87ceeb;
    touch-action: none;
    border: 3px solid #333;
    border-radius: 10px;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    color: #fff;
    font-weight: bold;
    font-size: 18px;
    text-shadow: 1px 1px 3px #000;
    user-select: none;
    z-index: 10;
  }
  /* Boutons tactiles pour mobile */
  #controls {
    position: fixed;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 400px;
    display: flex;
    justify-content: space-between;
    z-index: 10;
  }
  button.control-btn {
    background: rgba(0,0,0,0.4);
    border: none;
    border-radius: 10px;
    color: white;
    font-size: 24px;
    padding: 20px 25px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  button.control-btn:active {
    background: rgba(0,0,0,0.7);
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="480" height="270"></canvas>
<div id="ui">
  Vies: <span id="lives">3</span> | Score: <span id="score">0</span>
</div>
<div id="controls">
  <button id="leftBtn" class="control-btn">⬅️</button>
  <button id="jumpBtn" class="control-btn">⬆️</button>
  <button id="rightBtn" class="control-btn">➡️</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const livesDisplay = document.getElementById('lives');
  const scoreDisplay = document.getElementById('score');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');

  const gravity = 0.7;
  const friction = 0.8;

  const player = {
    x: 50,
    y: 0,
    width: 30,
    height: 50,
    color: '#ff5722',
    velX: 0,
    velY: 0,
    speed: 4,
    jumping: false,
    grounded: false,
    doubleJump: false,
  };

  let lives = 3;
  let score = 0;
  let gameOver = false;

  // Plateformes simples
  const platforms = [
    {x: 0, y: 250, width: 480, height: 20},
    {x: 100, y: 190, width: 100, height: 15},
    {x: 250, y: 130, width: 120, height: 15},
  ];

  // Pièces à collecter
  const coins = [
    {x: 120, y: 160, collected: false},
    {x: 280, y: 100, collected: false},
    {x: 400, y: 220, collected: false},
  ];

  // Ennemis simples qui patrouillent
  const enemies = [
    {x: 150, y: 230, width: 30, height: 20, dir: 1, speed: 2, color: '#0066ff'},
    {x: 300, y: 110, width: 30, height: 20, dir: -1, speed: 2.5, color: '#0066ff'},
  ];

  const keys = { left: false, right: false, jump: false };

  // Gestion clavier (desktop)
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = false;
  });

  // Gestion boutons tactiles mobile
  leftBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.left = true; });
  leftBtn.addEventListener('touchend', e => { e.preventDefault(); keys.left = false; });
  rightBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.right = true; });
  rightBtn.addEventListener('touchend', e => { e.preventDefault(); keys.right = false; });
  jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.jump = true; });
  jumpBtn.addEventListener('touchend', e => { e.preventDefault(); keys.jump = false; });

  function rectsColliding(r1, r2) {
    return !(r2.x > r1.x + r1.width || 
             r2.x + r2.width < r1.x || 
             r2.y > r1.y + r1.height ||
             r2.y + r2.height < r1.y);
  }

  function resetPlayer() {
    player.x = 50;
    player.y = 0;
    player.velX = 0;
    player.velY = 0;
    player.jumping = false;
    player.grounded = false;
    player.doubleJump = false;
  }

  function update() {
    if (gameOver) return;

    // Mouvements horizontaux
    if (keys.left) {
      player.velX = Math.max(player.velX - 0.5, -player.speed);
    } else if (keys.right) {
      player.velX = Math.min(player.velX + 0.5, player.speed);
    } else {
      player.velX *= friction;
      if (Math.abs(player.velX) < 0.1) player.velX = 0;
    }

    // Saut + double saut
    if (keys.jump) {
      if (!player.jumping && player.grounded) {
        player.velY = -15;
        player.jumping = true;
        player.grounded = false;
      } else if (player.jumping && !player.doubleJump && !player.grounded) {
        player.velY = -13;
        player.doubleJump = true;
      }
    }

    player.velY += gravity;
    player.x += player.velX;
    player.y += player.velY;

    // Collision avec plateformes
    player.grounded = false;
    for (let p of platforms) {
      // Simple AABB collision from top only
      if (player.x + player.width > p.x && player.x < p.x + p.width) {
        if (player.y + player.height > p.y && player.y + player.height < p.y + p.height) {
          player.y = p.y - player.height;
          player.velY = 0;
          player.grounded = true;
          player.jumping = false;
          player.doubleJump = false;
        }
      }
    }

    // Limites du canvas
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    if (player.y > canvas.height) {
      lives--;
      if (lives <= 0) {
        gameOver = true;
        alert('Game Over ! Score final: ' + score);
        document.location.reload();
      } else {
        resetPlayer();
      }
      livesDisplay.textContent = lives;
    }

    // Collecte pièces
    coins.forEach(c => {
      if (!c.collected) {
        const coinRect = {x: c.x, y: c.y, width: 20, height: 20};
        const playerRect = {x: player.x, y: player.y, width: player.width, height: player.height};
        if (rectsColliding(coinRect, playerRect)) {
          c.collected = true;
          score += 10;
          scoreDisplay.textContent = score;
        }
      }
    });

    // Déplacement ennemis
    enemies.forEach(e => {
      e.x += e.speed * e.dir;
      // Rebondir sur plateformes
      let onPlatform = false;
      for (let p of platforms) {
        if (e.x + e.width > p.x && e.x < p.x + p.width &&
            e.y + e.height === p.y) {
          onPlatform = true;
          if (e.x <= p.x) e.dir = 1;
          if (e.x + e.width >= p.x + p.width) e.dir = -1;
        }
      }
      if (!onPlatform) e.dir *= -1;

      // Collision avec joueur
      const enemyRect = {x: e.x, y: e.y, width: e.width, height: e.height};
      const playerRect = {x: player.x, y: player.y, width: player.width, height: player.height};
      if (rectsColliding(enemyRect, playerRect)) {
        lives--;
        livesDisplay.textContent = lives;
        if (lives <= 0) {
          gameOver = true;
          alert('Game Over ! Score final: ' + score);
          document.location.reload();
        } else {
          resetPlayer();
        }
      }
    });

    draw();
    requestAnimationFrame(update);
  }

  function draw() {
    // Nettoyer
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Dessiner plateformes
    ctx.fillStyle = '#654321';
    platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height));

    // Dessiner pièces
    coins.forEach(c => {
      if (!c.collected) {
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(c.x + 10, c.y + 10, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'orange';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    });

    // Dessiner ennemis
    enemies.forEach(e => {
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x, e.y, e.width, e.height);
    });

    // Dessiner joueur
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);
  }

  // Start
  resetPlayer();
  update();
})();
</script>

</body>
</html>
