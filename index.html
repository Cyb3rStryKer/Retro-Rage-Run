<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jeu plateforme pixel art</title>
<style>
  html, body {
    margin:0; padding:0; height:100%; background: #5ca0ff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
  }
  #gameContainer {
    position: relative;
    width: 100vw; height: 100vh;
    background: linear-gradient(to bottom, #90c8ff, #3b5998);
    overflow: hidden;
  }
  canvas {
    display: block;
    background: #80bfff;
    margin: 0 auto;
  }
  #ui {
    position: absolute;
    top: 5px; left: 10px;
    color: white;
    font-weight: bold;
    text-shadow: 0 0 5px #000;
    user-select:none;
    z-index: 10;
  }
  #settingsBtn {
    position: absolute;
    top: 5px; right: 5px;
    background: transparent;
    border: none;
    cursor: pointer;
    z-index: 20;
    width: 40px; height: 40px;
  }
  #settingsBtn svg {
    fill: white;
    filter: drop-shadow(0 0 2px #000);
  }
  #settingsPanel {
    position: absolute;
    top: 50px; right: 10px;
    background: rgba(0,0,0,0.85);
    color: white;
    padding: 15px;
    border-radius: 10px;
    width: 250px;
    font-size: 14px;
    display: none;
    z-index: 25;
  }
  #settingsPanel label {
    display: block;
    margin: 10px 0 5px;
  }
  #settingsPanel input[type="text"] {
    width: 40px;
    text-transform: uppercase;
    font-weight: bold;
    font-size: 14px;
    text-align: center;
  }
  #settingsCloseBtn {
    margin-top: 15px;
    background: #3b5998;
    border: none;
    padding: 8px 12px;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    width: 100%;
    font-weight: bold;
    font-size: 14px;
  }
  #messageBox {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9);
    color: white;
    padding: 30px 20px;
    border-radius: 15px;
    text-align: center;
    z-index: 30;
    display: none;
    width: 80vw;
    max-width: 300px;
    user-select:none;
  }
  #messageBox button {
    margin-top: 20px;
    padding: 10px 18px;
    font-size: 16px;
    font-weight: bold;
    background: #3b5998;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    color: white;
    width: 100%;
  }
  /* Mobile controls */
  #mobileControls {
    position: absolute;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
    z-index: 20;
    display: flex;
    gap: 15px;
    user-select:none;
  }
  .mobileBtn {
    width: 60px;
    height: 60px;
    background: rgba(59, 89, 152, 0.7);
    border-radius: 50%;
    color: white;
    font-size: 32px;
    line-height: 60px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 0 10px #1a3a7a;
    transition: background 0.3s ease;
    user-select:none;
  }
  .mobileBtn:active {
    background: rgba(59, 89, 152, 1);
  }
  /* Scrollbar removal for mobile */
  ::-webkit-scrollbar {
    display: none;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>

  <div id="ui"></div>

  <button id="settingsBtn" aria-label="Paramètres" title="Paramètres">
    <!-- simple gear icon SVG -->
    <svg viewBox="0 0 24 24" width="36" height="36" aria-hidden="true">
      <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7zm7.44-1.4l1.55-2.68-2.12-3.68-3.31.61a6.96 6.96 0 0 0-1.3-1.3l.6-3.3-3.68-2.12-2.7 1.56a8.09 8.09 0 0 0-1.68 2.12l-3.28-.45-1.95 3.36 1.68 2.93a7.06 7.06 0 0 0-1.5 3.48l-3.3.6 2.12 3.69 3.32-.6a7.06 7.06 0 0 0 1.5 3.47l-1.7 3.14 3.68 2.12 2.7-1.56a8.06 8.06 0 0 0 1.69-2.12l3.26.44 1.95-3.37-1.68-2.93a7.07 7.07 0 0 0 1.3-1.3z"/>
    </svg>
  </button>

  <div id="settingsPanel" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <h3 id="settingsTitle">Paramètres</h3>

    <label for="keyLeft">Déplacement gauche:</label>
    <input type="text" id="keyLeft" maxlength="1" autocomplete="off" />

    <label for="keyRight">Déplacement droite:</label>
    <input type="text" id="keyRight" maxlength="1" autocomplete="off" />

    <label for="keyJump">Saut:</label>
    <input type="text" id="keyJump" maxlength="1" autocomplete="off" />

    <label for="languageSelect">Langue:</label>
    <select id="languageSelect" aria-label="Choisir langue">
      <option value="fr">Français</option>
      <option value="en">English</option>
      <option value="de">Deutsch</option>
      <option value="es">Español</option>
    </select>

    <button id="settingsCloseBtn" aria-label="Fermer paramètres">Fermer</button>
  </div>

  <div id="messageBox" role="alertdialog" aria-live="assertive" aria-atomic="true">
    <div id="messageText"></div>
    <button id="messageButton" aria-label="Bouton message"></button>
  </div>

  <div id="mobileControls" aria-label="Contrôles mobiles">
    <div id="btnLeft" class="mobileBtn" aria-label="Gauche" role="button" tabindex="0">&#8592;</div>
    <div id="btnJump" class="mobileBtn" aria-label="Saut" role="button" tabindex="0">&#8679;</div>
    <div id="btnRight" class="mobileBtn" aria-label="Droite" role="button" tabindex="0">&#8594;</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let width, height;

  // Resize canvas to fit screen
  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }
  window.addEventListener('resize', resize);
  resize();

  // Settings & state
  let lang = 'fr';

  const translations = {
    fr: {
      level: 'Niveau',
      skin: 'Peau',
      died: 'Vous êtes mort!',
      retry: 'Réessayer',
      levelComplete: 'Niveau terminé!',
      next: 'Suivant',
      gameComplete: 'Félicitations! Vous avez fini le jeu!',
      replay: 'Rejouer',
      newSkinUnlocked: 'Nouvelle peau débloquée!'
    },
    en: {
      level: 'Level',
      skin: 'Skin',
      died: 'You died!',
      retry: 'Retry',
      levelComplete: 'Level complete!',
      next: 'Next',
      gameComplete: 'Congrats! You finished the game!',
      replay: 'Replay',
      newSkinUnlocked: 'New skin unlocked!'
    },
    de: {
      level: 'Level',
      skin: 'Skin',
      died: 'Du bist gestorben!',
      retry: 'Erneut versuchen',
      levelComplete: 'Level abgeschlossen!',
      next: 'Weiter',
      gameComplete: 'Glückwunsch! Du hast das Spiel beendet!',
      replay: 'Wiederholen',
      newSkinUnlocked: 'Neuer Skin freigeschaltet!'
    },
    es: {
      level: 'Nivel',
      skin: 'Aspecto',
      died: '¡Has muerto!',
      retry: 'Reintentar',
      levelComplete: '¡Nivel completado!',
      next: 'Siguiente',
      gameComplete: '¡Felicidades! ¡Terminaste el juego!',
      replay: 'Repetir',
      newSkinUnlocked: '¡Nuevo aspecto desbloqueado!'
    }
  };

  function t(key) {
    return translations[lang][key] || key;
  }

  // Game constants
  const tileSize = 40;
  const mapWidth = 20;
  const mapHeight = 12;
  const gravity = 0.9;
  const totalLevels = 20;

  // Player
  const player = {
    x: tileSize * 2,
    y: tileSize * (mapHeight - 3),
    width: 24,
    height: 32,
    vx: 0,
    vy: 0,
    speed: 5,
    jumpPower: 18,
    grounded: false,
    alive: true,
    skin: 'default'
  };

  // Skins (colors and simple face)
  const skins = {
    default: {name: 'Classique', color: '#d14a4a', eyes: '#000'},
    blue: {name: 'Bleu', color: '#4a79d1', eyes: '#e0f0ff'},
    green: {name: 'Vert', color: '#4ad156', eyes: '#0b3200'},
    orange: {name: 'Orange', color: '#d1864a', eyes: '#451f00'}
  };

  let unlockedSkins = ['default'];

  // Level data (0=empty,1=ground,2=spikes,3=laser,4=hole)
  // Each level array is mapHeight x mapWidth grid
  // Difficulty increases with more spikes, moving lasers and holes
  const levels = [];
  function generateLevel(n) {
    const level = [];
    for(let y=0; y<mapHeight; y++) {
      const row = [];
      for(let x=0; x<mapWidth; x++) {
        if(y === mapHeight - 1) {
          // Ground floor
          row.push(1);
        } else if (y === mapHeight - 2 && (x === mapWidth - 1 || x === 0)) {
          // Platforms at start and end one tile above ground
          row.push(1);
        } else if(n < 5) {
          // Easy: simple platforms
          row.push(0);
        } else if(n < 10) {
          // Medium: add spikes every 5 tiles
          if(y === mapHeight - 1 && x % 5 === 3) row.push(2);
          else row.push(0);
        } else if(n < 15) {
          // Hard: spikes + holes
          if(y === mapHeight - 1 && (x % 5 === 2 || x % 5 === 4)) row.push(2);
          else if(y === mapHeight - 1 && (x === 6 || x === 12)) row.push(4);
          else row.push(0);
        } else {
          // Very hard: spikes, holes, and lasers
          if(y === mapHeight - 1 && (x % 6 === 3 || x % 6 === 5)) row.push(2);
          else if(y === mapHeight - 1 && (x === 5 || x === 10 || x === 15)) row.push(4);
          else if(y === mapHeight - 4 && (x === 8 || x === 14)) row.push(3);
          else row.push(0);
        }
      }
      level.push(row);
    }
    return level;
  }
  for(let i=0; i<totalLevels; i++) {
    levels.push(generateLevel(i));
  }

  // Laser animation data
  const lasers = [];

  // Input controls
  let keysDown = {};
  let mobileInput = {left:false, right:false, jump:false};

  // Default controls keys, can be changed in settings
  let controls = {
    left: 'ArrowLeft',
    right: 'ArrowRight',
    jump: 'Space'
  };

  // UI elements
  const ui = document.getElementById('ui');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsPanel = document.getElementById('settingsPanel');
  const keyLeftInput = document.getElementById('keyLeft');
  const keyRightInput = document.getElementById('keyRight');
  const keyJumpInput = document.getElementById('keyJump');
  const languageSelect = document.getElementById('languageSelect');
  const settingsCloseBtn = document.getElementById('settingsCloseBtn');
  const messageBox = document.getElementById('messageBox');
  const messageText = document.getElementById('messageText');
  const messageButton = document.getElementById('messageButton');

  // Mobile buttons
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnJump = document.getElementById('btnJump');

  // Game state
  let currentLevel = 0;
  let isPaused = false;
  let showMessageActive = false;
  let lastTime = 0;

  // Save/load settings
  function saveSettings(){
    localStorage.setItem('platformerControls', JSON.stringify(controls));
    localStorage.setItem('platformerLang', lang);
    localStorage.setItem('platformerSkins', JSON.stringify(unlockedSkins));
  }
  function loadSettings(){
    const savedControls = localStorage.getItem('platformerControls');
    if(savedControls) {
      try {
        const c = JSON.parse(savedControls);
        if(c.left) controls.left = c.left.toUpperCase();
        if(c.right) controls.right = c.right.toUpperCase();
        if(c.jump) controls.jump = c.jump.toUpperCase();
      } catch{}
    }
    const savedLang = localStorage.getItem('platformerLang');
    if(savedLang && translations[savedLang]) lang = savedLang;
    const savedSkins = localStorage.getItem('platformerSkins');
    if(savedSkins) {
      try {
        const s = JSON.parse(savedSkins);
        if(Array.isArray(s)) unlockedSkins = s;
      } catch{}
    }
  }
  loadSettings();

  // Init settings UI inputs
  function initSettingsUI(){
    keyLeftInput.value = controls.left.length === 1 ? controls.left : '';
    keyRightInput.value = controls.right.length === 1 ? controls.right : '';
    keyJumpInput.value = controls.jump.length === 1 ? controls.jump : '';
    languageSelect.value = lang;
  }
  initSettingsUI();

  // Handle input for settings keys (only single char)
  function sanitizeKeyInput(e){
    let val = e.target.value.toUpperCase();
    if(val.length > 1) val = val[0];
    e.target.value = val;
  }
  keyLeftInput.addEventListener('input', sanitizeKeyInput);
  keyRightInput.addEventListener('input', sanitizeKeyInput);
  keyJumpInput.addEventListener('input', sanitizeKeyInput);

  // Apply settings changes
  settingsCloseBtn.addEventListener('click', () => {
    if(keyLeftInput.value) controls.left = keyLeftInput.value;
    if(keyRightInput.value) controls.right = keyRightInput.value;
    if(keyJumpInput.value) controls.jump = keyJumpInput.value;
    lang = languageSelect.value;
    saveSettings();
    settingsPanel.style.display = 'none';
    updateUIText();
  });

  // Toggle settings panel
  settingsBtn.addEventListener('click', () => {
    if(settingsPanel.style.display === 'block'){
      settingsPanel.style.display = 'none';
    } else {
      settingsPanel.style.display = 'block';
    }
  });

  // Message box control
  function showMessage(text, buttonText, callback){
    showMessageActive = true;
    messageText.textContent = text;
    messageButton.textContent = buttonText;
    messageBox.style.display = 'block';
    messageButton.onclick = () => {
      messageBox.style.display = 'none';
      showMessageActive = false;
      callback();
    };
  }

  // Keyboard input
  window.addEventListener('keydown', e => {
    keysDown[e.key.toUpperCase()] = true;
    // Prevent scrolling for space and arrows when game focused
    if([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e => {
    keysDown[e.key.toUpperCase()] = false;
  });

  // Mobile buttons input
  btnLeft.addEventListener('touchstart', e => { e.preventDefault(); mobileInput.left = true; });
  btnLeft.addEventListener('touchend', e => { e.preventDefault(); mobileInput.left = false; });
  btnRight.addEventListener('touchstart', e => { e.preventDefault(); mobileInput.right = true; });
  btnRight.addEventListener('touchend', e => { e.preventDefault(); mobileInput.right = false; });
  btnJump.addEventListener('touchstart', e => { e.preventDefault(); mobileInput.jump = true; });
  btnJump.addEventListener('touchend', e => { e.preventDefault(); mobileInput.jump = false; });

  // For accessibility, support keyboard on mobile buttons
  function bindKeyboardBtn(btn, action) {
    btn.addEventListener('keydown', e => {
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        mobileInput[action] = true;
      }
    });
    btn.addEventListener('keyup', e => {
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        mobileInput[action] = false;
      }
    });
  }
  bindKeyboardBtn(btnLeft, 'left');
  bindKeyboardBtn(btnRight, 'right');
  bindKeyboardBtn(btnJump, 'jump');

  // Utility: rectangle collision check
  function rectsOverlap(x1,y1,w1,h1,x2,y2,w2,h2){
    return !(x1+w1 < x2 || x1 > x2+w2 || y1+h1 < y2 || y1 > y2+h2);
  }

  // Check collision with level tiles
  function checkCollision(x, y, w, h){
    const tiles = [];
    const leftTile = Math.floor(x / tileSize);
    const rightTile = Math.floor((x + w) / tileSize);
    const topTile = Math.floor(y / tileSize);
    const bottomTile = Math.floor((y + h) / tileSize);

    for(let ty = topTile; ty <= bottomTile; ty++) {
      for(let tx = leftTile; tx <= rightTile; tx++){
        if(ty < 0 || ty >= mapHeight || tx < 0 || tx >= mapWidth) continue;
        const tile = levels[currentLevel][ty][tx];
        if(tile !== 0) tiles.push(tile);
      }
    }
    return tiles;
  }

  // Draw functions
  function drawTile(x, y, type){
    const px = x * tileSize;
    const py = y * tileSize;
    switch(type){
      case 1: // ground block
        // base brown block with shading
        ctx.fillStyle = '#7b5e00';
        ctx.fillRect(px, py, tileSize, tileSize);
        ctx.fillStyle = '#b28b00';
        ctx.fillRect(px + 5, py + 5, tileSize - 10, tileSize - 10);
        break;
      case 2: // spikes
        // white triangles on brown base
        ctx.fillStyle = '#7b5e00';
        ctx.fillRect(px, py, tileSize, tileSize);
        ctx.fillStyle = '#eee';
        for(let i=0; i<tileSize; i+=10){
          ctx.beginPath();
          ctx.moveTo(px+i, py+tileSize);
          ctx.lineTo(px+i+5, py+tileSize-15);
          ctx.lineTo(px+i+10, py+tileSize);
          ctx.closePath();
          ctx.fill();
        }
        break;
      case 3: // laser emitter
        // Red base block with black stripes and a laser beam animation (done in main loop)
        ctx.fillStyle = '#880000';
        ctx.fillRect(px, py, tileSize, tileSize);
        ctx.fillStyle = '#220000';
        for(let i=0; i<tileSize; i+=5){
          ctx.fillRect(px+i, py+8, 2, tileSize-16);
        }
        break;
      case 4: // hole
        // black hole with some shadow edges
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(px + tileSize/2, py + tileSize/2, tileSize/2 - 4, tileSize/3, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#330000';
        ctx.lineWidth = 3;
        ctx.stroke();
        break;
    }
  }

  // Draw player pixel art with skin
  function drawPlayer(){
    const px = player.x;
    const py = player.y;
    const s = skins[player.skin] || skins.default;

    // Body
    ctx.fillStyle = s.color;
    ctx.fillRect(px, py, player.width, player.height);

    // Eyes
    ctx.fillStyle = s.eyes;
    ctx.fillRect(px + 6, py + 8, 4, 4);
    ctx.fillRect(px + 14, py + 8, 4, 4);

    // Mouth
    ctx.fillStyle = '#330000';
    ctx.fillRect(px + 8, py + 22, 8, 2);

    // Simple shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(px, py + player.height - 6, player.width, 4);
  }

  // Draw laser beams (animated)
  function drawLasers(time){
    const levelData = levels[currentLevel];
    for(let y=0; y<mapHeight; y++){
      for(let x=0; x<mapWidth; x++){
        if(levelData[y][x] === 3){
          const px = x * tileSize;
          const py = y * tileSize;
          // animate beam flicker
          const flicker = (Math.sin(time/100 + x*2) + 1) / 2;
          ctx.fillStyle = `rgba(255,0,0,${0.5 + 0.5*flicker})`;
          ctx.fillRect(px + tileSize/2 - 5, py + tileSize, 10, tileSize*3);
        }
      }
    }
  }

  // Update player movement and collisions
  function updatePlayer(){
    if(!player.alive) return;

    // Input
    let moveLeft = keysDown[controls.left] || mobileInput.left;
    let moveRight = keysDown[controls.right] || mobileInput.right;
    let jumpPressed = keysDown[controls.jump] || mobileInput.jump;

    if(moveLeft) player.vx = -player.speed;
    else if(moveRight) player.vx = player.speed;
    else player.vx = 0;

    if(jumpPressed && player.grounded){
      player.vy = -player.jumpPower;
      player.grounded = false;
    }

    // Gravity
    player.vy += gravity;
    if(player.vy > 20) player.vy = 20; // terminal velocity

    // Horizontal collision
    let newX = player.x + player.vx;
    if(player.vx !== 0){
      const horizontalTiles = checkCollision(newX, player.y, player.width, player.height);
      if(horizontalTiles.some(t => t === 1)){
        // blocked, don't move horizontally
      } else {
        player.x = newX;
      }
    }

    // Vertical collision
    let newY = player.y + player.vy;
    const verticalTiles = checkCollision(player.x, newY, player.width, player.height);

    if(player.vy > 0){
      // Falling
      if(verticalTiles.some(t => t === 1)){
        player.grounded = true;
        player.vy = 0;
        player.y = Math.floor((newY + player.height) / tileSize) * tileSize - player.height;
      } else {
        player.grounded = false;
        player.y = newY;
      }
    } else if(player.vy < 0){
      // Going up
      if(verticalTiles.some(t => t === 1)){
        player.vy = 0;
        player.y = Math.floor(newY / tileSize + 1) * tileSize;
      } else {
        player.y = newY;
      }
    }

    // Death checks: spikes, lasers, holes
    const play
